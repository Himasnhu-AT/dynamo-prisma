// ! if prisma.schema exists, then appends after last model
// ? Partially implemented TODO: add secondary parser, to test for any possible bugs and recommend solutions, like automincement: true, type: int only.. so on..
// DONE TODO: if foreign key is false, type != anyModelType

// TODO: Add comment that this model is generated by schemaGenerator
// TOdo: create issue, if same model name defined in schema, then it should throw error in console, and not generate prisma schema

import { createModel, createScalarField } from "prisma-schema-dsl";
import {
  AUTO_INCREMENT,
  DataSourceProvider,
  DataSourceURLEnv,
  Enum,
  ScalarType,
  UUID,
} from "prisma-schema-dsl-types";
import { Field, Schema } from "./types/dynamoPrisma.types";
import { EMBEDDING_ALGO_SIZE } from "./utils/constants";

export function createModels(schema: Schema["schema"]): any[] {
  const models: any[] = [];
  for (const schemaItem of schema) {
    const fields: any[] = createFields(schemaItem.fields);
    models.push(createModel(schemaItem.schemaName, fields));
  }
  return models;
}

// increment is breaking the code
// ! ERROR: Error parsing JSON: Error: Default must be a number or call expression to autoincrement()
// ? Log by console.war:
/*  String;
    Default
    Default
    Default
    Default
    Default
    Int 
*/
export function createFields(fields: Field[]): any[] {
  // console.error("Feilds: ", fields);
  const result: any[] = [];
  for (const fieldData of fields) {
    result.push(
      createScalarField(
        fieldData.fieldName,
        fieldData.type as ScalarType,
        fieldData.isList || undefined, //isList boolean | undefined
        !fieldData.isNullable || false, //isRequired boolean | undefined
        fieldData.isId ? fieldData.isId : fieldData.isUnique || false,
        fieldData.isId || false,
        undefined, // isUpdatedAt
        fieldData.isId && fieldData.isAutoIncrement
          ? { callee: AUTO_INCREMENT }
          : fieldData.isId && fieldData.isUuid
          ? { callee: UUID }
          : fieldData.default || undefined, // default values SaclarFeildDefault | undefined
        undefined, // documentation string | undefined
        fieldData.isForeignKey || false // isForeignKey boolean | undefined
        // `@map("${fieldData.fieldName}")` // attributes in string | string[] | undefined
      )
    );

    if (fieldData.isVectorEmbed) {
      if (
        Object.keys(EMBEDDING_ALGO_SIZE).includes(fieldData.embeddingAlgo) ===
        false
      ) {
        throw new Error(
          `Embedding algorithm ${fieldData.embeddingAlgo} not supported.`
        );
      }
      result.push(
        createScalarField(
          `${fieldData.fieldName}Algorithm`,
          "String" as ScalarType,
          false,
          true,
          false,
          false,
          undefined,
          `"${fieldData.embeddingAlgo}"`,
          undefined,
          undefined,
          undefined
        ),

        createScalarField(
          `${fieldData.fieldName}Embedding`,
          `Unsupported("vector(${
            EMBEDDING_ALGO_SIZE[fieldData.embeddingAlgo]
          })")?` as ScalarType,
          false,
          true,
          false,
          false,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined
        )
      );
    }
  }
  // console.log("Results: ", result);
  return result;
}
